<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Query.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;DocumentNavigator3&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">ca.sharcnet.nerve.docnav.query</a> &gt; <span class="el_source">Query.java</span></div><h1>Query.java</h1><pre class="source lang-java linenums">package ca.sharcnet.nerve.docnav.query;

import ca.sharcnet.nerve.docnav.dom.ElementNode;
import ca.sharcnet.nerve.docnav.dom.IsNodeType;
import ca.sharcnet.nerve.docnav.dom.Node;
import ca.sharcnet.nerve.docnav.dom.NodeList;
import ca.sharcnet.nerve.docnav.dom.NodeType;
import ca.sharcnet.nerve.docnav.dom.TextNode;
import java.util.Arrays;
import java.util.List;

public class Query extends NodeList {
    private SelectAny selectAny;

<span class="fc" id="L15">    public Query() {</span>
<span class="fc" id="L16">    }</span>

<span class="fc" id="L18">    public Query(Iterable&lt;Node&gt; iterable, String select) {</span>
<span class="fc" id="L19">        selectAny = new SelectAny(select);</span>

<span class="fc bfc" id="L21" title="All 2 branches covered.">        for (Node element : iterable) {</span>
<span class="fc bfc" id="L22" title="All 2 branches covered.">            if (selectAny.check(element)) this.add(element);</span>
<span class="fc" id="L23">        }</span>
<span class="fc" id="L24">    }</span>

    @Override
    public String toString() {
<span class="fc bfc" id="L28" title="All 2 branches covered.">        if (this.isEmpty()) return &quot;[]&quot;;</span>

<span class="fc" id="L30">        StringBuilder builder = new StringBuilder();</span>

<span class="fc" id="L32">        builder.append(&quot;[&quot;);</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">        for (int i = 0; i &lt; this.size() - 1; i++) {</span>
<span class="fc" id="L34">            builder.append(this.get(i).toSelect()).append(&quot;, &quot;);</span>
        }
<span class="fc" id="L36">        builder.append(this.get(this.size() - 1).toSelect());</span>
<span class="fc" id="L37">        builder.append(&quot;]&quot;);</span>
<span class="fc" id="L38">        return builder.toString();</span>
    }

    /* Query operations */
    /**
     * @param select A select string with format information
     * @param args Arguments referenced by the format specifiers in the format string. If there are more arguments than format
     * specifiers, the extra arguments are ignored. The number of arguments is variable and may be zero. The maximum number
     * of arguments is limited by the maximum dimension of a Java array as defined by The Javaâ„¢ Virtual Machine
     * Specification. The behaviour on a null argument depends on the conversion.
     * @return
     */
    public Query filterf(String select, Object... args) {
<span class="fc" id="L51">        return new Query(this, String.format(select, args));</span>
    }

    public Query filter(String select){
<span class="fc" id="L55">        return new Query(this, select);</span>
    }

    /**
        Change the name of all elements in this query return the value of the first element.
        @param name
     */
    public String name(String name) {
<span class="fc" id="L63">        this.forEach(n -&gt; n.setName(name));</span>
<span class="fc" id="L64">        return this.get(0).getName();</span>
    }

    /**
        Return the name value of the first element in this query.'
        Returns null if there are no selected elements.
     */
    public String name() {
<span class="fc bfc" id="L72" title="All 2 branches covered.">        if (this.isEmpty()) return null;</span>
<span class="fc" id="L73">        return this.get(0).getName();</span>
    }

    /**
        Adds the specified class(es) to each element in the set of matched elements.  Each string is assumed to be a
        space seperated list of class names. It's important to note that this method does not replace a class. It simply
        adds the class, appending it to any which may already be assigned to the elements. It will only add the class
        if it is not already present.
        @param classNames Zero or more strings, each of which is a space deliminated list of classNames.
     */
    public void addClass(String... classNames) {
<span class="fc" id="L84">        this.forEach(node -&gt; {</span>
<span class="fc" id="L85">            String prevClassAttr = node.getAttributeValue(&quot;class&quot;);</span>
<span class="fc" id="L86">            List&lt;String&gt; has = Arrays.asList(prevClassAttr.split(&quot;[ ]+&quot;));</span>

<span class="fc bfc" id="L88" title="All 2 branches covered.">            for (String s1 : classNames) {</span>
<span class="fc" id="L89">                String[] split = s1.split(&quot;[ ]+&quot;);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">                for (String s2 : split) {</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">                    if (!has.contains(s2)) {</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">                        if (prevClassAttr.isEmpty()) prevClassAttr = s2;</span>
<span class="fc" id="L93">                        else prevClassAttr += &quot; &quot; + s2;</span>
                    }
                }
            }

<span class="fc" id="L98">            node.addAttribute(&quot;class&quot;, prevClassAttr);</span>
<span class="fc" id="L99">        });</span>
<span class="fc" id="L100">    }</span>

    /**
        Determine whether any of the matched elements are assigned the given class.
        @param classNames Zero or more strings, each of which is a space deliminated list of classNames.
        @return true if any element in the query contains any of the listed classnames.
     */
    public boolean hasClass(String... classNames) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (Node node : this) {</span>
<span class="fc" id="L109">            String prevClassAttr = node.getAttributeValue(&quot;class&quot;);</span>
<span class="fc" id="L110">            List&lt;String&gt; has = Arrays.asList(prevClassAttr.split(&quot;[ ]+&quot;));</span>

<span class="fc bfc" id="L112" title="All 2 branches covered.">            for (String s1 : classNames) {</span>
<span class="fc" id="L113">                String[] split = s1.split(&quot;[ ]+&quot;);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">                for (String s2 : split) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                    if (has.contains(s2)) return true;</span>
                }
            }
<span class="fc" id="L118">        };</span>
<span class="fc" id="L119">        return false;</span>
    }

    /**
    Description: Remove a single class, multiple classes, or all classes from each element in the set of matched
    elements.  If one or more class names are included as a parameter, then only those classes will be removed from the
    set of matched elements. If no class names are specified in the parameter, all classes will be removed.  If the
    class name is repeated in the class attribute the behavior is undefined.
    @param classNames
     */
    public void removeClass(String... classNames) {
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (classNames.length == 0) {</span>
<span class="fc" id="L131">            this.forEach(n -&gt; n.removeAttribute(&quot;class&quot;));</span>
<span class="fc" id="L132">            return;</span>
        }

<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (Node node : this) {</span>
<span class="fc" id="L136">            String prevClassAttr = node.getAttributeValue(&quot;class&quot;);</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">            for (String s1 : classNames) {</span>
<span class="fc" id="L139">                String[] split = s1.split(&quot;[ ]+&quot;);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">                for (String s2 : split) {</span>
<span class="fc" id="L141">                    prevClassAttr = prevClassAttr.replaceAll(s2, &quot;&quot;);</span>
                }
            }

<span class="fc" id="L145">            prevClassAttr = prevClassAttr.trim();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (prevClassAttr.isEmpty()) node.removeAttribute(&quot;class&quot;);</span>
<span class="fc" id="L147">            else node.addAttribute(&quot;class&quot;, prevClassAttr);</span>
<span class="fc" id="L148">        }</span>
<span class="fc" id="L149">    }</span>

    /**
        Remove all matched elements from the document after refining the selection.
     * @param select
     */
    public void remove(String select) {
<span class="fc" id="L156">        Query filter = this.filter(select);</span>
<span class="fc" id="L157">        filter.detach();</span>
<span class="fc" id="L158">    }</span>

    /**
        Remove all matched elements from the document.
     */
    public void detach() {
        try {
<span class="fc" id="L165">            this.forEach(node -&gt; node.detach());</span>
<span class="fc" id="L166">        } catch (NullPointerException ex) {</span>
<span class="fc" id="L167">            throw new QueryOperationException(ex);</span>
<span class="fc" id="L168">        }</span>
<span class="fc" id="L169">    }</span>

    /**
    Replace all selected nodes with their children.
     */
    public void extract() {
<span class="fc" id="L175">        this.forEach(node -&gt; node.replaceWithChildren());</span>
<span class="fc" id="L176">    }</span>

    /**
    Retrieve the attribute value for the first matched element.  Returns a null if no attribute is found or the set is
    empty.
    @param key
    @param value
    @return
     */
    public String attr(String key) {
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (this.isEmpty()) return null;</span>
<span class="fc" id="L187">        Node node = this.get(0);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (!node.hasAttribute(key)) return null;</span>
<span class="fc" id="L189">        return node.getAttributeValue(key);</span>
    }

    /**
    Determine if the first matched element contains the given attribute.
    Returns false if no elements are selected.
    @param key
    @param value
    @return
     */
    public Boolean hasAttr(String key) {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (this.isEmpty()) return false;</span>
<span class="fc" id="L201">        Node node = this.get(0);</span>
<span class="fc" id="L202">        return node.hasAttribute(key);</span>
    }

    /**
    Remove the attribute for all matched elements.  No operation taken on elements without the attribute.
    empty.
    @param key
    @return
     */
    public void removeAttr(String key) {
<span class="fc" id="L212">        this.forEach(node -&gt; node.removeAttribute(key));</span>
<span class="fc" id="L213">    }</span>

    /**
    Set the attribute of all matched element.s
    @param key
    @param value
     */
    public void attr(String key, Object value) {
<span class="fc" id="L221">        this.forEach(node -&gt; node.addAttribute(key, value));</span>
<span class="fc" id="L222">    }</span>

    /**
        Return the child elemants of each matched element as a new query.
     */
    public Query children(IsNodeType... types) {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (types.length == 0) types = new IsNodeType[]{NodeType.ELEMENT};</span>
<span class="fc" id="L229">        Query query = new Query();</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        for (Node node : this) query.add(node.childNodes(types));</span>
<span class="fc" id="L231">        return query;</span>
    }

    /**
    Return a new query of elements which are contained in both queries.
    @param that
    @return
     */
    public Query intersect(Query match) {
<span class="fc" id="L240">        Query query = new Query();</span>
<span class="fc" id="L241">        this.forEach(n1 -&gt; {</span>
<span class="fc" id="L242">            match.forEach(n2 -&gt; {</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">                if (n1 == n2) query.add(n1);</span>
<span class="fc" id="L244">            });</span>
<span class="fc" id="L245">        });</span>
<span class="fc" id="L246">        return query;</span>
    }

    /**
    Return a new query of elements which are 'this' and not in 'that'.
    @param that
    @return
     */
    public Query unique(Query that) {
<span class="fc" id="L255">        Query query = new Query();</span>
<span class="fc" id="L256">        this.forEach(n1 -&gt; {</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (!that.contains(n1)) query.add(n1);</span>
<span class="fc" id="L258">        });</span>
<span class="fc" id="L259">        return query;</span>
    }

    /**
    Return a new query of elements which are 'this' or in 'that', but not in both.
    @param that
    @return
     */
    public Query xor(Query that) {
<span class="fc" id="L268">        Query query = new Query();</span>
<span class="fc" id="L269">        this.forEach(node -&gt; {</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">            if (!that.contains(node)) query.add(node);</span>
<span class="fc" id="L271">        });</span>
<span class="fc" id="L272">        that.forEach(node -&gt; {</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">            if (!this.contains(node)) query.add(node);</span>
<span class="fc" id="L274">        });</span>
<span class="fc" id="L275">        return query;</span>
    }

    /**
    Returns the text content of the first element (and all it's decendents).
     * @return The text of the first element, or null if query is empty.
     */
    public String text() {
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (this.isEmpty()) return null;</span>
<span class="fc" id="L284">        return this.get(0).innerText();</span>
    }

    /**
    Replaces all children of each selected element with a single text node containing the specified string.
     * @param string
     */
    public void text(String string) {
<span class="fc" id="L292">        this.forEach(node -&gt; {</span>
<span class="fc" id="L293">            node.clearChildren();</span>
<span class="fc" id="L294">            node.addChild(new TextNode(string));</span>
<span class="fc" id="L295">        });</span>
<span class="fc" id="L296">    }</span>

    /**
    Create a copy of each selected node.  These copies will be detached from a parent, but will
    contain children, copies of which may also be returned.
    @return a query containing all copies.
     */
    public Query copy() {
<span class="fc" id="L304">        Query query = new Query();</span>
<span class="fc" id="L305">        this.forEach(n -&gt; query.add(n.copy()));</span>
<span class="fc" id="L306">        return query;</span>
    }

    /**
     * Add a copy of 'node' to the beginning of each selected element.  Given the child nodes of a selected element
     * = {c0 ... cN}, child nodes + {n0 ... nN} = {n0 ... nN, c0 ... cN}.
     * @param nodes
     */
    public void append(Iterable&lt;Node&gt; nodes) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">        for (Node n : this) {</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">            for (Node m : nodes) {</span>
<span class="fc" id="L317">                n.addChild(m.copy());</span>
<span class="fc" id="L318">            }</span>
<span class="fc" id="L319">        }</span>
<span class="fc" id="L320">    }</span>

    /**
     * Add a copy of 'node' to the beginning of each selected element.  Given the child nodes of a selected element
     * = {c0 ... cN}, child nodes + {n0 ... nN} = {n0 ... nN, c0 ... cN}.
     * @param nodes
     */
    public void prepend(Iterable&lt;Node&gt; nodes) {
<span class="fc bfc" id="L328" title="All 2 branches covered.">        for (Node n : this) {</span>
<span class="fc" id="L329">            int k = 0;</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">            for (Node m : nodes) {</span>
<span class="fc" id="L331">                n.addChild(k++, m.copy());</span>
<span class="fc" id="L332">            }</span>
<span class="fc" id="L333">        }</span>
<span class="fc" id="L334">    }</span>

    /**
    Attach a new node with 'name' to the end of all selected elements.
    @param name
    @return a query containing all new nodes.
     */
    public Query appendNew(String name) {
<span class="fc" id="L342">        Query query = new Query();</span>
<span class="fc" id="L343">        this.forEach(n -&gt; {</span>
<span class="fc" id="L344">            Node elementNode = new ElementNode(name);</span>
<span class="fc" id="L345">            query.add(elementNode);</span>
<span class="fc" id="L346">            n.addChild(elementNode);</span>
<span class="fc" id="L347">        });</span>
<span class="fc" id="L348">        return query;</span>
    }

    /**
    Attach a new node with 'name' to the beginning of all selected elements.
    @param name
    @return a query containing all new nodes.
     */
    public Query prependNew(String name) {
<span class="fc" id="L357">        Query query = new Query();</span>
<span class="fc" id="L358">        this.forEach(n -&gt; {</span>
<span class="fc" id="L359">            Node elementNode = new ElementNode(name);</span>
<span class="fc" id="L360">            query.add(0, elementNode);</span>
<span class="fc" id="L361">            n.addChild(0, elementNode);</span>
<span class="fc" id="L362">        });</span>
<span class="fc" id="L363">        return query;</span>
    }

    /**
     * Replace all selected elements with a copy of 'node'.  All of the child nodes of the selected elements will be
     * discarded.
     * @param node
     * @return a new Query object containing all new copies created by this method.
     */
    public Query replaceWith(Node node) {
<span class="fc" id="L373">        Query query = new Query();</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        for (Node element : this) {</span>
<span class="fc" id="L375">            Node copy = node.copy();</span>
<span class="fc" id="L376">            query.add(copy);</span>
<span class="fc" id="L377">            element.replaceWith(copy);</span>
<span class="fc" id="L378">        }</span>
<span class="fc" id="L379">        return query;</span>
    }

    /**
    Return the first node, null if empty.
    @return
    */
    public Node first() {
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (this.isEmpty()) return null;</span>
<span class="fc" id="L388">        return this.get(0);</span>
    }

    /**
    Return the last node, null if empty.
    @return
    */
    public Node last() {
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (this.isEmpty()) return null;</span>
<span class="fc" id="L397">        return this.get(this.size() - 1);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>